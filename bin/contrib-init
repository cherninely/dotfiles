#!/usr/bin/env python
"""
Init the contrib repo
Usage:
cd <contrib-directory> && contrib-init [--git-hooks]

--git-hooks Parameter creates a lint to the .githooks dir in the root of project

Example:
cd ~/wc1/web3/libs/z-afisha && contrib-init
"""
import json
import os
import re
import subprocess
import sys


class ColorPrinter(object):
    HEADER = '\033[35m'
    GREEN = '\033[32m'
    WHITE = '\033[37m'
    WARNING = '\033[34m'
    FAIL = '\033[31m'
    END_COLOR = '\033[0m'

    @classmethod
    def print_header(cls, string):
        cls._print(cls.HEADER, string)

    @classmethod
    def print_ok(cls, string):
        cls._print(cls.GREEN, string)

    @classmethod
    def print_warning(cls, string):
        cls._print(cls.WARNING, string)

    @classmethod
    def print_fail(cls, string):
        cls._print(cls.FAIL, string)

    @classmethod
    def print_white(cls, string):
        cls._print(cls.WHITE, string)

    @classmethod
    def _print(cls, color, string):
        print color + string + cls.END_COLOR


def main():
    all_right = True
    working_dir = os.getcwd()
    path_parts = working_dir[1:].split('/')
    if path_parts[-2] not in ('libs', 'contribs'):
        raise EnvironmentError('The working dir must be a contrib dir')

    if os.path.exists(working_dir + '/.git'):
        raise EnvironmentError('This directory is already a Git repository')

    contrib_info = get_contrib_info(working_dir, path_parts)

    git('init')
    git('remote add origin {0}'.format(contrib_info['origin_url']))
    git('fetch')

    # create local master branch
    git('add .')
    git('reset origin/master')

    # checkout to bower.json ref
    need_stash_apply = git_stash()
    try:
        checkout_branch(contrib_info)
    except BaseException as e:
        all_right = False
        ColorPrinter.print_warning('Warning: Can not checkout to ref, make it manually')
        ColorPrinter.print_white('Reason:\n' + str(e))

    if need_stash_apply:
        try:
            git('stash apply')
        except RuntimeError:
            all_right = False
            ColorPrinter.print_warning('Warning: Stash is not applied')
            git('status')

    if '--git-hooks' in sys.argv:
        try:
            set_git_hooks()
        except BaseException as e:
            all_right = False
            ColorPrinter.print_warning("Warning: can't set git hooks")
            ColorPrinter.print_white('Reason:\n' + str(e))

    if all_right:
        ColorPrinter.print_ok('Flawless victory')
    else:
        ColorPrinter.print_warning('Process ends with some issues')


def get_contrib_info(working_dir, path_parts):
    bower_file = os.path.abspath(working_dir + '/../../bower.json')
    if not os.path.exists(bower_file):
        raise EnvironmentError('bower.json not found in path {0}'.format(bower_file))
    bower_data = json.loads(open(bower_file, 'r').read())

    contrib_name = path_parts[-1]
    contrib_bower_info = bower_data.get('dependencies', {}).get(contrib_name)
    if contrib_bower_info is None:
        raise RuntimeError('Can not extract info from bower.json')

    # github.yandex-team.ru
    match = re.findall('^(?P<repo>[\w\.-]+)/(?P<name>[\w\.-]+)#(?P<ref>[\w\./-]+)(?:#\s*(?P<change_time>.+)\s*)?$',
                       contrib_bower_info)
    if match:
        groups = match[0]
        origin_url = 'git@github.yandex-team.ru:{0}/{1}.git'.format(groups[0], groups[1])
        return {
            'hosting': 'github.yandex-team.ru',
            'repo': groups[0],
            'name': groups[1],
            'ref': groups[2],
            'change_time': groups[3],
            'origin_url': origin_url
        }

    # external hosting like github.com
    match = re.findall(
        ('^(?:(?:git|https)://)?'
         '(?P<hosting>[\w\.]+)/'
         '(?P<repo>[\w\.-]+)/'
         '(?P<name>[\w\.-]+)'
         '#(?P<ref>[\w\./-]+)'
         '(?:#\s*(?P<change_time>.+)?\s*)?$'),
        contrib_bower_info
    )
    if not match:
        raise RuntimeError('Unexpected bower data format')

    groups = match[0]
    origin_url = 'git@{0}:{1}/{2}.git'.format(groups[0], groups[1], groups[2])
    return {
        'hosting': groups[0],
        'repo': groups[1],
        'name': groups[2],
        'ref': groups[3],
        'change_time': groups[4],
        'origin_url': origin_url
    }


def git(action):
    ColorPrinter.print_header('Git exec: git ' + action)
    program = ['git']
    params = action.split(' ')
    code = subprocess.call(program + params)
    if code != 0:
        raise RuntimeError('Git error')


def git_stash():
    p = subprocess.Popen(('git', 'stash'),
                         stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    output, err = p.communicate()
    if err:
        raise RuntimeError('Git error: ' + err)

    need_apply = not output.startswith('No local changes')
    if need_apply:
        ColorPrinter.print_ok('Your changes stashed')
    else:
        ColorPrinter.print_white('No changes to stash')
    return need_apply


def checkout_branch(contrib_info):
    if re.match('^[0-9a-f]{40}$', contrib_info['ref']):
        # SHA-1 hash case
        branch_info = get_remote_branch_of_commit(contrib_info['ref'])
        if branch_info['branch'] != 'master':
            clean_fs()
            action = 'checkout -b {0} {1}'.format(branch_info['branch'], branch_info['full_name'])
            git(action)  # checking out to the new branch
    else:
        # Branch name case
        clean_fs()
        git('checkout -b {0} origin/{0}'.format(contrib_info['ref']))  # checking out to the new branch


def clean_fs():
    git('reset --hard')
    git('clean -fd -e .bower.json')


def get_remote_branch_of_commit(ref):
    p = subprocess.Popen(('git', 'branch', '-r', '--contains', ref),
                         stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    output, err = p.communicate()
    if err:
        raise RuntimeError('Git error: ' + err)
    elif not output:
        raise RuntimeError('Unexpected branch info')

    # if this commit in master then checkout master
    master_match = re.findall('^\s*((?P<remote>.+?)/master)\s*$', output, re.M)
    if master_match:
        groups = master_match[0]
        return {
            'remote': groups[1],
            'branch': 'master',
            'full_name': groups[0],
        }

    # if commit contains in many branches we took the first of them
    branch_string = output.split('\n')[0].strip()
    branch_match = re.findall('^(?P<remote>.+?)/(?P<branch>.+)$', branch_string)
    if not branch_match:
        raise RuntimeError('Unexpected remote branch name format: ' + output)

    groups = branch_match[0]
    return {
        'remote': groups[0],
        'branch': groups[1],
        'full_name': branch_string,
    }


def set_git_hooks():
    project_dir = '../../'
    hooks_bin = project_dir + 'node_modules/.bin/git-hooks'
    additional_hooks = project_dir + '.githooks'
    if os.path.isfile(hooks_bin) and os.access(hooks_bin, os.X_OK):
        ColorPrinter.print_white('Setup Git hooks')
        if os.path.isdir('.git/hooks.old'):
            subprocess.call([hooks_bin, '--uninstall'])
        subprocess.call([hooks_bin, '--install'])

        if os.path.isdir(additional_hooks) and not os.path.exists('.githooks'):
            os.symlink(additional_hooks, '.githooks')
    else:
        raise EnvironmentError('git-hooks not found or isn\'t executable')


if __name__ == '__main__':
    try:
        main()
    except BaseException as e:
        message = e.__class__.__name__ + ': ' + str(e)
        ColorPrinter.print_fail(message)
